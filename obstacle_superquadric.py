import numpy as np
import copy

class Obstacle_Static:
    '''
    Implementation of an obstacle for Dynamic Movement Primitives written as a
    general n-ellipsoid
      / x - x_c \ 2n     / y - y_c \ 2n      / z - z_c \ 2n
     |-----------|   +  |-----------|   +   |-----------|     =  1
      \    a    /        \    b    /         \    c    /
    '''

    # def __init__(self, center = np.zeros(2), axis = np.ones(2), coeffs = np.ones(2), A = 1.0, eta = 1.0, **kwargs):
    def __init__(self, obstacles, A = 1.0, eta = 1.0, **kwargs):
        self.obstacles = obstacles

        self.A = copy.deepcopy(A)
        self.eta = copy.deepcopy(eta)
        self.n_dim = np.size(obstacles[0]["radius"])

    def gen_external_force_per_obstacle(self, obs_k, x):
        '''
        Compute the forcing term generated by the potential U as
          varphi(x) = - nabla U
        '''
        phi = np.zeros(self.n_dim)
        for i in range(self.n_dim):
            phi[i] = (((x[i] - obs_k["center"][i]) ** (2 * obs_k["order"][i] - 1)) / (obs_k["radius"][i] ** (2 * obs_k["order"][i])))
        K = self.compute_isopotential(obs_k, x)
        phi *= (self.A * np.exp(-self.eta*K)) * (self.eta / K + 1. / K / K) * (2 * obs_k["order"])
        return np.reshape(phi,(self.n_dim,1))

    # def compute_potential(self, x):
    #     '''
    #     Compute the potential
    #              exp (- eta K)
    #       U = A ---------------
    #                    K
    #     '''
    #     K = self.compute_isopotential (x)
    #     U = self.A * np.exp(- self.eta * K) / K
    #     return U

    def compute_isopotential(self, obs_k, x):
        '''
        Compute the isopotential of the obstacle
                / x - x_c \ 2n     / y - y_c \ 2n      / z - z_c \ 2n
         K  =  |-----------|   +  |-----------|   +   |-----------|     -  1
                \    a    /        \    b    /         \    c    /
        '''
        K = 0.0
        for i in range(self.n_dim):
            K += ((x[i] - obs_k["center"][i]) / obs_k["radius"][i]) ** (2 * obs_k["order"][i])
        K -= 1
        return K
    
    def gen_external_force(self, x):
        if x.ndim != 1:
            x = x.reshape(-1)

        f = np.zeros((self.n_dim,1))
        for obstacle in self.obstacles:
            f += self.gen_external_force_per_obstacle(obstacle, x)
        return f



